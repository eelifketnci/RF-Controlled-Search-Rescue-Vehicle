#include <math.h>
#include <string.h>
//led değişkenleri
int red = 12;
int white = 11;
int yellow = 10;
int green = 9;

// Pin tanımlamaları
int xPin = A0; 
int yPin = A1; 
int butonPin = 2; 


// Pozisyon değişkenleri
int xPozisyon;
int yPozisyon;

// Sürüş modu sayacı
int surusmod = 0; // Bu değişkeni global olarak tanımlamalıyız

// --- Millis() için Gerekli Global Değişkenler ---

// 1. Buton Debounce (Parazit Engelleme) için değişkenler
int sonButonDurum = HIGH;         // Butonun bir önceki durumunu saklar (PULLUP olduğu için başlangıçta HIGH)
unsigned long sonBasmaZamani = 0; // Son geçerli basma anının zaman damgası
unsigned long debounceSuresi = 100;  // Buton paraziti için 50 milisaniye bekleme süresi

// 2. Serial Ekrana Yazdırma Zamanlayıcısı için değişkenler
unsigned long sonYazdirmaZamani = 0; // Son yazdırma işleminin zaman damgası
unsigned long yazdirmaAraligi = 1000;  // 1000ms = 1 saniyede bir yazdır


#define BUTTON_PIN 8
char mesaj[7];
char basamakArray[3];

int button_state = 0;       // bizim toggle değişkenimiz
int last_button_read = 0;   // butonun bir önceki okunan değeri
int debounceDuration = 20;  // debounce süresi (ms)
unsigned long lastDebounceTime = 0;

void setup() {
  Serial.begin(9600);
  pinMode(BUTTON_PIN, INPUT);
  pinMode(xPin, INPUT);
  pinMode(yPin, INPUT);
  pinMode(butonPin, INPUT_PULLUP); // INPUT_PULLUP: Basılmadığında 1 (HIGH), basıldığında 0 (LOW)
  pinMode(red,OUTPUT);
  pinMode(white,OUTPUT);
  pinMode(green,OUTPUT);
  pinMode(yellow,OUTPUT);
}

void loop() {
  int reading = digitalRead(BUTTON_PIN);
  // Güncel Joystick değerlerini OKU
  xPozisyon = analogRead(xPin);
  yPozisyon = analogRead(yPin);

  if (reading != last_button_read) {
    lastDebounceTime = millis();
  }

  /* bu değişimin gerçek bir basış mı yoksa zıplama mı olduğunu bilmiyoruz.
    O yüzden sadece zamanı kaydediyoruz */


  /*Butonun mekanşk yapısında dolayı bazen elektriksel gürültü olabilmektedir bu yüzden butona gerçekten basılıp basılmadığını anlamak için 
  belirli bir süre (debounceduration) butonun aynı durumda kalması beklenir*/

  if ((millis() - lastDebounceTime) > debounceDuration) {
    // sadece LOW -> HIGH geçişinde toggle yap
    static int lastStableState = LOW;
    if (reading == HIGH && lastStableState == LOW) {
      button_state = !button_state;
      Serial.println(button_state);
    }
    lastStableState = reading;
  }

  last_button_read = reading;
if(button_state){
  // --- 1. Buton Kontrolü (Debounce ile) ---
  
  // Butonun şu anki durumunu oku
  int mevcutButonDurum = digitalRead(butonPin);
  
  // Durum değişikliğini kontrol et:
  // Eğer buton *önceden* HIGH (basılmıyor) iken *şimdi* LOW (basılıyor) olduysa...
  if (mevcutButonDurum == LOW && sonButonDurum == HIGH) {
    
    // Parazit kontrolü: Son basıştan bu yana yeterli süre (50ms) geçti mi?
    if (millis() - sonBasmaZamani > debounceSuresi) {
      
      // Evet, bu geçerli bir basma. Sayacı artır.
      surusmod++;
      
      // Sayaç 4 olduysa sıfırla (sizin kodunuzdaki mantık)
      if (surusmod == 3) {
        surusmod = 0;
      }
      
      // Bu geçerli basmanın zamanını kaydet
      sonBasmaZamani = millis();
    }
  }
  
  // Bir sonraki döngüde karşılaştırma yapabilmek için butonun son durumunu kaydet
  sonButonDurum = mevcutButonDurum;
  switch(surusmod){
    case 0:
    mesaj[0]='S';
    mesaj[4]='C';
    mesaj[5]='F';
    digitalWrite(white,HIGH);
    digitalWrite(red, LOW);
    digitalWrite(green, LOW);
    digitalWrite(yellow, LOW);
    if(abs(512-xPozisyon)>abs(512-yPozisyon)){
      int xHiz=0;
      if(xPozisyon>530){
        mesaj[1]='0';
        xHiz=map(xPozisyon,512,1023,0,99);
        itoa(xHiz, basamakArray, 10);
        mesaj[2]=basamakArray[0];
        mesaj[3]=basamakArray[1];
      }
      else if(xPozisyon<500){
        mesaj[1]='1';
        xHiz=map(xPozisyon,0,512,99,0);
        itoa(xHiz, basamakArray, 10);
        mesaj[2]=basamakArray[0];
        mesaj[3]=basamakArray[1];
      }
      else{
          mesaj[4]='C';
          mesaj[5]='F';
          mesaj[0]='S';
          mesaj[1]='0';
          mesaj[2]='0';
          mesaj[3]='0';

      }


    }
    else{
      int yHiz=0;
      if(yPozisyon>530){
        mesaj[1]='2';
        yHiz=map(yPozisyon,512,1023,0,99);
        itoa(yHiz, basamakArray, 10);
        mesaj[2]=basamakArray[0];
        mesaj[3]=basamakArray[1];
      }
      else if(yPozisyon<500){
        mesaj[1]='3';
        yHiz=map(yPozisyon,0,512,99,0);
        itoa(yHiz, basamakArray, 10);
        mesaj[2]=basamakArray[0];
        mesaj[3]=basamakArray[1];
      }
      else{
          mesaj[4]='C';
          mesaj[5]='F';
          mesaj[0]='S';
          mesaj[1]='0';
          mesaj[2]='0';
          mesaj[3]='0';

      }
    }
    break;


    case 1:
    mesaj[0]='D';
    mesaj[4]='C';
    mesaj[5]='F';
    digitalWrite(yellow,HIGH);
    digitalWrite(red, LOW);
    digitalWrite(green, LOW);
    digitalWrite(white, LOW);
    if(abs(512-xPozisyon)>abs(512-yPozisyon)){
      int xHiz=0;
      if(xPozisyon>530){
        mesaj[1]='0';
        xHiz=map(xPozisyon,512,1023,0,99);
        itoa(xHiz, basamakArray, 10);
        mesaj[2]=basamakArray[0];
        mesaj[3]=basamakArray[1];
      }
      else if(xPozisyon<500){
        mesaj[1]='1';
        xHiz=map(xPozisyon,0,512,99,0);
        itoa(xHiz, basamakArray, 10);
        mesaj[2]=basamakArray[0];
        mesaj[3]=basamakArray[1];
      }
      else{
          mesaj[4]='C';
          mesaj[5]='F';
          mesaj[0]='D';
          mesaj[1]='0';
          mesaj[2]='0';
          mesaj[3]='0';

      }
    }
    else{
      int yHiz=0;
      if(yPozisyon>530){
        mesaj[1]='2';
        yHiz=map(yPozisyon,512,1023,0,99);
        itoa(yHiz, basamakArray, 10);
        mesaj[2]=basamakArray[0];
        mesaj[3]=basamakArray[1];
      }
      else if(yPozisyon<500){
        mesaj[1]='3';
        yHiz=map(yPozisyon,0,512,99,0);
        itoa(yHiz, basamakArray, 10);
        mesaj[2]=basamakArray[0];
        mesaj[3]=basamakArray[1];
      }
      else{
          mesaj[4]='C';
          mesaj[5]='F';
          mesaj[0]='D';
          mesaj[1]='0';
          mesaj[2]='0';
          mesaj[3]='0';

      }
    }

    break;
    case 2:
    mesaj[0]='R';
    mesaj[4]='C';
    mesaj[5]='F';
    int xHiz=0;
    if(xPozisyon>530){
      mesaj[1]='0';
      xHiz=map(xPozisyon,512,1023,0,99);
      itoa(xHiz, basamakArray, 10);
      mesaj[2]=basamakArray[0];
      mesaj[3]=basamakArray[1];
    }
    else if(xPozisyon<500){
      mesaj[1]='1';
      xHiz=map(xPozisyon,0,512,99,0);
      itoa(xHiz, basamakArray, 10);
      mesaj[2]=basamakArray[0];
      mesaj[3]=basamakArray[1];
    }
    else{
          mesaj[4]='C';
          mesaj[5]='F';
          mesaj[0]='R';
          mesaj[1]='0';
          mesaj[2]='0';
          mesaj[3]='0';

      }
    digitalWrite(green,HIGH);
    digitalWrite(white, LOW);
    digitalWrite(yellow, LOW);
    digitalWrite(red, LOW);
    break;

  }



  // --- 2. Serial Ekrana Yazdırma (Non-Blocking) ---
  
  // Son yazdırmadan bu yana 1 saniye (yazdirmaAraligi) geçti mi?
  if (millis() - sonYazdirmaZamani >= yazdirmaAraligi) {
    
    // Geçtiyse, yazdırma zamanını güncelle
    sonYazdirmaZamani = millis();
    
    
    
    // Değerleri yazdır
    Serial.print("X Pozisyonu: ");
    Serial.print(xPozisyon);
    Serial.print(" | Y Pozisyonu: ");
    Serial.print(yPozisyon);
    Serial.print(" | Buton Durum (Anlık): ");
    Serial.print(mevcutButonDurum); // Anlık durumu (0 veya 1) gösterir
    Serial.print(" | Surus Modu: ");
    Serial.println(surusmod);
  }
  
  // loop() fonksiyonunun sonunda delay(1000) YOK!
  // Bu sayede program sürekli çalışır ve butona basıldığı anı kaçırmaz.

}
else{
  digitalWrite(red, HIGH);
  digitalWrite(white, LOW);
  digitalWrite(yellow, LOW);
  digitalWrite(green, LOW);
  mesaj[4]='C';
  mesaj[5]='F';
  mesaj[0]='E';
  mesaj[1]='0';
  mesaj[2]='0';
  mesaj[3]='0';
  
}

Serial.println(mesaj);
delay(100);
  
  
}
